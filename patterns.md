# SOLID

## Принципы:
1. Single responsibility - принцип единственной отвественности.  
Пишем код (класс, метод, интерфейс, функция) таким образом, чтобы он решал одну задачу.  
Плюсы:
    * используем меньше зависимостей (импортов);
    * меньше связность кода (зависимость одной части кода от другой);
    * больше гибкость;
    * проще тестировать;
    * проще обслуживать.

2. Open/closed - принцип открытости/закрытости.  
При необходимости изменения логики работы кода, реализовывать новый функционал обособлено, а не изменять старый.  
Плюсы:
    * старая логика никак не пострадает;
    * возможность переключения между новой и старой логикой.

3. Liskov substitution - принцип подстановки.  
Объекты (классы) в программе должны быть заменяемы экземплярами их подтипов без ущерба корректности работы программы.

4. Interface segregation - принцип разделения интерфейсов.  
Стремиться разбивать интерфейсы на интерфейсы поменьше.  
Плюсы:
    * меньшая связанность компонентов;
    * классы реализуют только нужные им интерфейсы.

5. Dependecy inversion - принцип инверсии зависимостей.  
Зависимость должна быть от абстракций, а не от конкретных реализаций.

# Паттерны

1. Порождающие - шаблоны проектирования связаны с механизмом создания новых объектов.
    * Строитель - интерфейс для пошагового создания сложных объектов.
    * Фабрика - общий интерфейс для создания объектов в суперклассе, позволяющий подклассам определять тип создаваемого объекта.
    * Одиночка - гарантирует, что у класса есть только один экземпляр и предоставляет глобальную точку доступа к нему.

2. Поведенчиские - определяют взаимодействие между классами и объектами, их обязанностями и алгоритмы поведения.
    * Стратегия - позволяет объединить несколько алгоритмов в группу. Порядок применения алгоритмов может изменяться, благодаря чему достигается гибкость всей системы.
    * Команда - добавляет слой абстракции между действием и объектом, который это действие вызывает, например, кнопка и действие, которое выполняется при нажатии на эту кнопку.

3. Структурные - определяют метод сборки объектов и классов в более сложные структуры, сохраняя при этом гибкость и эффективность.
    * Фасад - предоставляет унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы.
    * Прокси - обертка над объектом с таким же интерфейсом, но имеющая дополнительную логику, например логирование.
    * Адаптер - шаблон используется, если требуется изменить интерфейс без ущерба для разработки.

